### 试题A
**【题目】**　组队
	作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员，组成球队的首发阵容。
	每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1号位至 5 号位的评分之和最大可能是多少？

> 方法一：观察法
>
> * 可直接从表中观察出答案. 

>　方法二：编程
>
>* 根据**广度优先**搜索或**宽度**优先搜索可解决

```cpp
>待续
```



### 试题Ｂ

**【题目】** 年号字串

​	明用字母 `A` 对应数字 1，`B` 对应 2，以此类推，用 `Z` 对应 26。对于 27以上的数字，小明用两位或更长位的字符串来对应，例如 `AA` 对应 27，`AB` 对
​	应 28，`AZ `对应 52，`LQ `对应 329。请问 2019 对应的字符串是什么？

**【答案提交】**

​	<font size=2>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
​	个大写英文字符串，在提交答案时只填写这个字符串，注意全部大写，填写多
​	余的内容将无法得分。</font>

> 递归定义：待完成

```c++
#include<iostream>
#include<stack>//栈实现
using namespace std;

//递归实现
void fun(int n){
    if(n!=0){
        fun(n/26);
        printf("%c",n%26+'A'-1);
    }
}

int main(){
    int n=2019;
    stack<int>st;

    fun(n);
    cout<<endl;
    
    //栈实现
    while(n){
        st.push(n);
        n/=26;
    }
    while(!st.empty()){
        printf("%c",'A'+st.top()%26-1);
        st.pop();
    }
    return 0;
}

```



### 试题C

**【题目】**　数列求值

​	给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求第 20190324 项的最后 4 位数字。

**【答案提交】**s
	<font size=2>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个 4 位整数（提示：答案的千位不为 0） ，在提交答案时只填写这个整数，填写多余的内容将无法得分。</font>

```c++
#include<iostream>
#include<vector>
using namespace std;

int main(){
    int n;
    cin>>n;
    vector<int>vi(n);
    vi[0]=1,vi[1]=1,vi[2]=1;
    for(int i=3;i<vi.size();i++){
        vi[i]=(vi[i-1]+vi[i-2]+vi[i-3])%10000;
    }
    cout<<vi.back();
    return 0;
}
```



### 试题D

**【题目】** 数的分解

​	把 2019分解成 3个各不相同的正整数之和，并且要求每个正整数都不包
​	含数字2和4，一共有多少种不同的分解方法？
​	注意交换 3个整数的顺序被视为同一种方法，例如 `1000+1001+18`和
​	`1001+1000+18`被视为同一种。

<font size=2>【答案提交】</font>
​	<font size=2>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</font>



> 暴力解法，直接三重循环，再每次判断是否会被`2`或`4`整除.



```c++
#include<iostream>

using namespace std;

bool check(int a) {
	int n = a, t = 0;
	while (n) {
		t = n % 10;
		n /= 10;
		if (t == 2 || t == 4)return false;
	}
	return true;
}

int main() {
	int ans = 0;
	for (int i = 1; i < 2017; i++) {
		if (!check(i))continue;
		for (int j = i+1; j < 2018; j++) {
			if (!check(j))continue;
			for (int k = j+1; k < 2019; k++) {
				if (!check(k))continue;
				if (i + j + k == 2019) {
					ans++;
				}
			}
		}
	}
	cout << ans << endl;
	getchar();
	return 0;
}
```



### 试题I



### 试题 J

**【题目背景】**
<font size=2>在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 `AOE` 单位，在
游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对
一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的
刺蛇飞龙等低血量单位。</font>

【问题描述】
<font size=2>你控制着 n 名高阶圣堂武士，方便起见标为 1, 2, · · · , n。每名高阶圣堂武士
需要一定的灵能来战斗，每个人有一个灵能值 a<sub>i</sub> 表示其拥有的灵能的多少（a<sub>i</sub>
非负表示这名高阶圣堂武士比在最佳状态下多余了 a<sub>i</sub> 点灵能，a<sub>i</sub> 为负则表示这
名高阶圣堂武士还需要 −a<sub>i </sub>点灵能才能到达最佳战斗状态）。现在系统赋予了
你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2, n − 1]，若
a<sub>i</sub> ≥ 0 则其两旁的高阶圣堂武士，也就是 i − 1、i + 1 这两名高阶圣堂武士会从
i 这名高阶圣堂武士这里各抽取 a<sub>i</sub> 点灵能；若 a<sub>i</sub> < 0 则其两旁的高阶圣堂武士，
也就是 i − 1, i + 1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −a<sub>i</sub> 点灵能。形
式化来讲就是 a<sub>i</sub>−1+ = a<sub>i</sub>, a<sub>i</sub>+1+ =a<sub>i</sub>, a<sub>i</sub>− = 2a<sub>i</sub>。
灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂
武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为
max<sub>i=1</sub><sup>n</sup>|a<sub>i</sub>|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武
士的不稳定度最小。</font>

**【输入格式】**<font size=2>本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。
接下来依次输入每一组询问。
每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。
接下来一行包含 n 个数 a<sub>1</sub>, a<sub>2</sub>, · · · ,a<sub>n</sub>。</font>



**【输出格式】**
<font size=2>输出 T 行。每行一个整数依次表示每组询问的答案。</font>
【样例输入】

> 3
> 3
> 5 -2 3
> 4
> 0 0 0 0
> 3
> 1 2 3



**【样例输出】**

> 3
> 0
> 3

**【样例说明】**
<font size=2>对于第一组询问：
对 2 号高阶圣堂武士进行传输操作后 a<sub>1</sub> = 3，a<sub>2</sub> = 2，a<sub>3</sub> = 1。答案为 3。
对于第二组询问：
这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。</font>



**【样例输入】**

> 3
> 4
> -1 -2 -3 7
> 4
> 2 3 4 -8
> 5
> -1 -1 6 -1 -1



**【样例输出】**

> 5
> 7
> 4



**【样例输入】**
见文件`trans3.in`。
【样例输出】
见文件`trans3.ans`。



**【数据规模与约定】**
<font size=2>对于所有评测用例，T ≤ 3，3 ≤ n ≤ 300000，|a<sub>i</sub> | ≤ 109。</font>

评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下：
评测用例编号 n |a<sub>i</sub>

> | 特殊性质
> 1 = 3 ≤ 1000 无
> 2,3 ≤ 5 ≤ 1000 无
> 4,5,6,7 ≤ 10 ≤ 1000 无
> 8,9,10 ≤ 20 ≤ 1000 无
> 11 ≤ 100 ≤ 109 所有 a<sub>i</sub> 非负
> 12,13,14 ≤ 100 ≤ 109 无
> 15,16 ≤ 500 ≤ 109 无
> 17,18,19 ≤ 5000 ≤ 109 无
> 20 ≤ 5000 ≤ 109 所有 a<sub>i</sub> 非负
> 21 ≤ 100000 ≤ 109 所有 a<sub>i</sub> 非负
> 22,23 ≤ 100000 ≤ 109 无
> 24,25 ≤ 300000 ≤ 109 无
> 注意：本题输入量较大请使用快速的读入方式。



思路：

> 从题目中我们可以的得出 max={|a<sub>1</sub>|, |a<sub>2</sub>|, |a<sub>2</sub>| &bull;&bull;&bull; |a<sub>n</sub>|}.
>
> 我们所求的是`max`中的最大值中的最小值.
>
> 用前缀和表示每一个个数：max={|s<sub>1</sub>-s<sub>0</sub>|, |s<sub>2</sub>-s<sub>1</sub>|, &bull;&bull;&bull; |s<sub>n-1</sub>-s<sub>n-1</sub>|}.
>
> 那么问题就转化为：求两个相邻`s`的差的绝对值的最大值的最小值.
>
> * 已知 S<sub>0</sub> 和 S<sub>n</sub> .
>
> * 情况如下：
>
>  1. 如果 s<sub>0</sub> 和 s<sub>n</sub> 刚好为最小值好和最大值（或相反），那么此时就是最优解. 原因如下：
>
>     * 随便设四个点，s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, s<sub>4</sub>, 如果 s<sub>1</sub> < s<sub>3</sub> < s<sub>2</sub> < s<sub>4</sub> 成立，如果交换 s<sub>2</sub> 和 s<sub>3</sub> 的**值**使得四个点满足单调递增，得：s<sub>1</sub>, s<sub>2</sub>', s<sub>3</sub>' s<sub>4</sub>.
>
>     ​	设：L<sub>1</sub>= |s<sub>2</sub> - s<sub>1</sub>|，L<sub>2</sub> = |s<sub>4</sub> - s<sub>3</sub>|，L<sub>1</sub>' = |s<sub>2</sub>' - s<sub>1</sub>|，L<sub>2</sub>' = |s<sub>4</sub> - s<sub>3</sub>'|.
>
>     ​	我们很容易知道原来中间两个值差的绝对值是不变的，从上面列的式子我们可以得到，L<sub>1</sub> &le; L<sub>1</sub>'，L<sub>2</sub> &le; L<sub>2</sub>' .
>
>     
>
>     ​	结论：交换两个值后，这两个值与前(或后)一个点的差会变小或不变.
>     
>     
>     
>     ​	最后**P<sub>1</sub>**：[当 S<sub>0</sub> 和 S<sub>n</sub> 刚好为最小值好和最大值（或相反)，经过再次排序后]，一定会是一组最优解.
>     
>     
>     
> 2. 当`s`本身不是单调序列时.
>
>    * 此时s<sub>0</sub> 和 s<sub>n</sub> 的值一定会在排列后的数组的中间.
>
>    ​	我们可以从`1`中得到**P<sub>1</sub>**结论，总会得到一组最优解法.
>
>    假设：当从s<sub>0</sub> 开始时s<sub>n</sub>结束，每一次跳2个单位时是最优解.
>    
>    我们在横坐标上可以列四个点{1, 2, 3, 4}，如果第一组为｛<1,4>，<2,3>｝，第二组为｛<1,３>，<2,４>｝.
>    
>    |4-2|=3，|3-2|=1.
>    
>    |3-1|=2，|4-2|=2.
>    
>    那么有：set_1={3，１}＝３．set_2={2，２}＝２;
>    
>    很显然：set_2 比 set_1 稳定，那么跳的个数为２为最优解.



```c++

```

























































































